---
title: "master thesis"
author: "Carlo Greß"
date: "2024-03-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r}
library(tidyverse)
library(sf)
library(sp)
library(ggplot2)
library(plotly)
library(leaflet)
library(mapview)
library(tmap)
```

# Loading required geodata files 

## Germany (Constituencies)

```{r}
# Load the shapefile
shapefile_path <- "Data sources/btw21_geometrie_wahlkreise_vg250_geo_shp/Geometrie_Wahlkreise_20DBT_VG250_geo.shp"
wahlkreise_germany <- st_read(shapefile_path)

# Assuming UTM Zone 32N as the projected CRS for Germany
utm_crs <- "EPSG:32632"
wahlkreise_germany <- st_transform(wahlkreise_germany, crs = utm_crs)
utm_crs_germany <- st_crs(wahlkreise_germany)

# Plot the shapefile on a map without labels and the coordinate system
g <- ggplot() +
  geom_sf(data = wahlkreise_germany, fill = "white", color = "black") +
  labs(title = "German Wahlkreise", x = NULL, y = NULL) + # Remove axis titles
  theme_void() + # This removes background, gridlines, and text
  theme(plot.title = element_text(hjust = 0.5)) # Center the title

ggsave("wahlkreise_germany_map_large.png", plot = g, width = 16, height = 12, dpi = 300)
```

## Berlin (Electoral district borders for state elections, "Abgeordnetenhauswahl")

```{r}
shapefile_path_ah_wk <- "Data sources/RBS_OD_Wahlkreise_AH2021/AWK_AH21_25833.shp"
ah_wk <- st_read(shapefile_path_ah_wk)

# Ensure the second shapefile has the same CRS as the first
if (!st_crs(ah_wk) == utm_crs_germany) {
  ah_wk <- st_transform(ah_wk, utm_crs_germany)
}

# Plotting 
ggplot() +
  geom_sf(data = ah_wk, fill = "lightgray", color = "black") +
  theme_void() + # Removes background, gridlines, and text
  theme(plot.margin = margin(0, 0, 0, 0, "cm")) # Optional: Remove margins around the plot

# Saving
ggsave("ah_wk_map_large.png", width = 15, height = 10, dpi = 300)
```
### RBS-Blocks (most granular spatial level of Berlin geometry)

```{r}
bloecke_path <- "Data sources/rbs_bloecke_wfs/rbs_bloecke_wfs.shp"
bloecke <- st_read(bloecke_path)
bloecke <- st_transform(bloecke, utm_crs_germany)

# Plotting Blockflächen with specified aesthetics
ggplot() +
  geom_sf(data = bloecke, fill = "lightgray", color = "black") +
  theme_void() + # Removes background, gridlines, and text
  theme(plot.margin = margin(0, 0, 0, 0, "cm")) + # Optional: Remove margins around the plot
  ggtitle("Blockflächen") + # Adds a title
  theme(plot.title = element_text(hjust = 0.5)) # Center the title

# To display the plot in an R environment (like RStudio), just run the code above.
# If you need to save the plot to a file, you can use ggsave with specified dimensions for a larger figure.
ggsave("bloecke_map_large.png", width = 15, height = 10, dpi = 300)
```
# Reading in data that has been spatially in joined in QGIS

### RBS blocks with consituency meta information

```{r}
shapefile_path <- "Data sources/qgis spatial join/secondtry.shp"
rbs_ah_bt <- st_read(shapefile_path)
rbs_ah_bt <- st_transform(rbs_ah_bt, utm_crs_germany)

# Plotting the shapefile
ggplot() +
  geom_sf(data = rbs_ah_bt, fill = "lightgray", color = "black") +
  theme_void() +
  theme(plot.margin = margin(0, 0, 0, 0, "cm"))

ggsave("rbs_ah_bt_map.png", width = 15, height = 10, dpi = 300)

rbs_ah_bt_df <- as.data.frame(rbs_ah_bt)
write.csv(rbs_ah_bt_df, "rbs_ah_bt.csv", row.names = FALSE)
```
Since the RBS and the constituency borders are not perfectly aligned, some few blocks (26 out of the 15940 blocks) have been mistakenly assigned to the wrong constituencies. The next code chunk manually corrects the flawed values. 

```{r}
berlin_final <- rbs_ah_bt_df |> 
  mutate(
    WKR_NR = case_when(
      LAND_NAME != "Berlin" & WKR_NR == 58 ~ 77,
      LAND_NAME != "Berlin" & WKR_NR == 59 ~ 85,
      LAND_NAME != "Berlin" & WKR_NR == 61 ~ 79,
      LAND_NAME != "Berlin" & WKR_NR == 62 ~ 84,
      LAND_NAME != "Berlin" & WKR_NR == 63 ~ 84,
      TRUE ~ WKR_NR
    ),
    WKR_NAME = case_when(
      LAND_NAME != "Berlin" & WKR_NR == 77 ~ "Berlin-Reinickendorf",
      LAND_NAME != "Berlin" & WKR_NR == 85 ~ "Berlin-Marzahn-Hellersdorf",
      LAND_NAME != "Berlin" & WKR_NR == 79 ~ "Berlin-Steglitz-Zehlendorf",
      LAND_NAME != "Berlin" & WKR_NR == 84 & WKR_NAME != "Berlin-Treptow-Köpenick" ~ "Berlin-Treptow-Köpenick",
      TRUE ~ WKR_NAME
    ),
    LAND_NAME = ifelse(LAND_NAME != "Berlin", "Berlin", LAND_NAME),
    LAND_NR = ifelse(LAND_NAME == "Berlin", as.numeric(11), LAND_NR)
  )

berlin_final <- berlin_final |> 
  mutate( 
    WKR_NR = case_when(blknr == 171601 ~ 76,
    TRUE ~ WKR_NR),
    WKR_NAME = case_when(blknr == 171601  ~ "Berlin-Pankow",
    TRUE ~ WKR_NAME)
    )
```

Visualising the final RBS blocks, coloring based on whether the block is occupied or not

```{r}
# Transforming the dataframe into an sf object for plotting 
berlin_final_sf <- st_as_sf(berlin_final, crs = utm_crs_germany)

# Plot the map using ggplot2
ggplot() +
  geom_sf(data = filter(berlin_final_sf, ewk != "unbewohnt"), aes(fill = "Occupied"), size = 0.5, alpha = 0.5) +
  geom_sf(data = filter(berlin_final_sf, ewk == "unbewohnt"), aes(fill = "Unoccupied"), size = 0.5, alpha = 0.5) +
  scale_fill_manual(values = c("Unoccupied" = "red", "Occupied" = "blue")) +
  theme_void() + # Remove axes
  theme(legend.position = "right", legend.title = element_blank(), legend.text = element_text(size = 10))

# If needed, save the plot to a file
ggsave("final_figures/berlin_blocks_map.png", width = 15, height = 15, dpi = 300)

```

# Demographic data

## Germany 

```{r}

csv_file_path <- "Data sources/bundestagswahlkreise/btw21_strukturdaten.csv"

# Define the locale with German notation
german_locale <- locale(decimal_mark = ",", grouping_mark = ".")

# Load the CSV file
btw_21 <- read_delim(csv_file_path, delim = ';', skip = 8, col_names = TRUE, locale = german_locale)

# Keep demographic variables only 
btw_21 <- btw_21 |> 
  select(1:17)

# Rename the columns
btw_21 <- btw_21 |> 
  rename(
    Country = `Land`,
    DistrictNo = `Wahlkreis-Nr.`,
    DistrictName = `Wahlkreis-Name`,
    Municipalities = `Gemeinden am 31.12.2019 (Anzahl)`,
    Area = `Fläche am 31.12.2019 (km²)`,
    TotalPopulation = `Bevölkerung am 31.12.2019 - Insgesamt (in 1000)`,
    GermanPopulation = `Bevölkerung am 31.12.2019 - Deutsche (in 1000)`,
    ForeignersPercentage = `Bevölkerung am 31.12.2019 - Ausländer/-innen (%)`,
    PopulationDensity = `Bevölkerungsdichte am 31.12.2019 (EW je km²)`,
    BirthRate = `Zu- (+) bzw. Abnahme (-) der Bevölkerung 2019 - Geburtensaldo (je 1000 EW)`,
    MigrationRate = `Zu- (+) bzw. Abnahme (-) der Bevölkerung 2019 - Wanderungssaldo (je 1000 EW)`,
    Age_Under18 = `Alter von ... bis ... Jahren am 31.12.2019 - unter 18 (%)`,
    Age_18_24 = `Alter von ... bis ... Jahren am 31.12.2019 - 18-24 (%)`,
    Age_25_34 = `Alter von ... bis ... Jahren am 31.12.2019 - 25-34 (%)`,
    Age_35_59 = `Alter von ... bis ... Jahren am 31.12.2019 - 35-59 (%)`,
    Age_60_74 = `Alter von ... bis ... Jahren am 31.12.2019 - 60-74 (%)`,
    Age_75plus = `Alter von ... bis ... Jahren am 31.12.2019 - 75 und mehr (%)`
  )

# Adjust 'Area', 'TotalPopulation', and 'GermanPopulation' by multiplying by 1000 (original data was measured in thousands)
btw_21 <- btw_21 |> 
  mutate(Area = Area * 1000,
         TotalPopulation = TotalPopulation * 1000,
         GermanPopulation = GermanPopulation * 1000) |> 
  # Filter rows where 'DistrictNo' is less than or equal to 299. This effectively means to only consider the real constituency rows, not any cumulative measures
  filter(DistrictNo <= 299)
```

```{r}
# Calculate average values
average_total_population <- mean(btw_21$TotalPopulation, na.rm = TRUE)
average_german_population <- mean(btw_21$GermanPopulation, na.rm = TRUE)
average_foreigners_percentage <- mean(btw_21$ForeignersPercentage, na.rm = TRUE)

# Print the results
cat("Average Total Population:", sprintf("%.2f", average_total_population), "\n")
cat("Average German Population:", sprintf("%.2f", average_german_population), "\n")
cat("Average Foreigners Percentage:", sprintf("%.2f", average_foreigners_percentage), "\n")
```

Creating a new variable that indicates the deviation of the German population from the average German population as a share. Additionally, we add the gemometry of the constituencies in order to be able to plot the later results. For that purpose, we cann use the `wahlkreise_germany` object

```{r}
btw_21 <- btw_21 |> 
  mutate(deviation = (GermanPopulation - average_german_population) / average_german_population * 100)

# Merge btw_21 with wahlkreise_germany

# Adjust btw_21 by removing leading zeros from DistrictNo
btw_21 <- btw_21 %>%
  mutate(DistrictNo = as.numeric(as.character(DistrictNo)))

btw_21 <- btw_21 %>%
  left_join(wahlkreise_germany %>% select(WKR_NR, geometry), by = c("DistrictNo" = "WKR_NR"))

btw_21_sf <- st_as_sf(btw_21, crs = st_crs(utm_crs_germany))
```

Next, we will create a plot that shows how much the constituencies deviate from the average population number 

```{r}
ggplot(data = btw_21_sf) +
  geom_sf(aes(fill = deviation), color = "0.8", size = 0.8) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in %)", limits = c(min(btw_21_sf$deviation, na.rm = TRUE), max(btw_21_sf$deviation, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12)) +
  theme(legend.position = "right")

# Display the plot
ggsave("population_deviation_map.png", width = 12, height = 8, dpi = 300)
```
Now, I am creating a similar plot that only shows the constituencies that have a deviation of below -15 %or above 15 %. These constituencies should, when possible, be redistricted. 
```{r}
btw_21_sf <- btw_21_sf |> 
  mutate(deviation15 = ifelse(deviation < -15 | deviation > 15, 1, 0))

# Plot all constituencies, coloring by deviation value or grey if not significant
ggplot(data = btw_21_sf) +
  geom_sf(data = btw_21_sf %>% filter(deviation15 == 0), fill = "grey", color = NA, size = 0.1) +
  geom_sf(data = btw_21_sf %>% filter(deviation15 == 1), aes(fill = deviation), color = NA, size = 0.1) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in per cent)", 
                       limits = c(min(btw_21_sf$deviation, na.rm = TRUE), max(btw_21_sf$deviation, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.position = "right")

ggsave("final_figures/deviation15.png", width = 12, height = 8, dpi = 300)
```
Let's briefly check the minimum and maximum values of deviation as well as the number of consituencies with such a deviation. If a consituency falls below -25 or above 25 per cent deviation, it needs to be redistricted (mandatory). 

```{r}
btw_21_sf |> 
  filter(deviation15 == 1) |> 
  length()

cat("District with min. deviation:", btw_21_sf$DistrictName[which.min(btw_21_sf$deviation)], sprintf("(%.2f)", min(btw_21_sf$deviation)), "\n")
cat("District with max. deviation:", btw_21_sf$DistrictName[which.max(btw_21_sf$deviation)], sprintf("(%.2f)", max(btw_21_sf$deviation)), "\n")

```

Next, we are creating a plot that shows the foreigner's percentage per constituency. Additionally, we'll highlight the constituencies with the min/max value.

```{r}
highlighted_constituencies <- highlighted_constituencies |>
  mutate(centroid = st_centroid(geometry))

# Now, use the calculated centroids for x and y in geom_text
ggplot(data = btw_21_sf) +
  geom_sf(aes(fill = ForeignersPercentage), color = NA) +
  scale_fill_viridis_c(option = "plasma", name = "Foreigners Percentage") +
  #geom_sf(data = highlighted_constituencies, color = "black", size = 0.5, show.legend = FALSE) +
 # geom_text(data = highlighted_constituencies, aes(x = st_coordinates(centroid)[,1], y = st_coordinates(centroid)[,2], label = paste0(DistrictName, "\n", sprintf("%.2f%%", ForeignersPercentage))), size = 3, color = "black") +
  theme_void() +
  theme(plot.title = element_text(size = 14),
        plot.subtitle = element_text(size = 10),
        legend.position = "right")

ggsave("final_figures/foreigners_percentage_annotated.png", width = 12, height = 8, dpi = 300)
```

Avg. population sizes of consituencies with and without foreigners as well as constituencies per state. 

```{r}
average_german_population_per_row <- round(mean(btw_21$GermanPopulation, na.rm = TRUE))

# Calculate the average Total Population
average_total_population <- round(mean(btw_21$TotalPopulation, na.rm = TRUE))

# Calculate the current number of constituencies per state
constituencies_per_state <- btw_21 %>%
  group_by(Country) %>%
  summarise(NumberOfConstituencies = n())

# Print the results
cat("Average German Population:", sprintf("%.2f", average_german_population_per_row), "\n")
cat("Average Total Population:", sprintf("%.2f", average_total_population), "\n")
cat("Current number of constituencies per state:\n")
print(constituencies_per_state)

# As we can see from the output, considering foreigners increases the average population size per constituency by almost 35,000 inhabitants, from 243,373 to 278,148.Furthermore, we can derive that Nordrhein-Westfalen has the highest number of electoral districts (64), while Bremen only has 2. 
```

Next, we want to calculate, how many constituencies each state should receive when foreigner considered. In the last chunk, we already calculated the avg. population size including foreigners. 

```{r}
divisor <- mean(btw_21$TotalPopulation, na.rm = TRUE)

# Sum total population per country (Bundesland)
total_population_per_country <- btw_21 %>%
  group_by(Country) %>%
  summarise(TotalPopulation = sum(TotalPopulation, na.rm = TRUE)) %>%
  ungroup()

# Divide the total population of each Bundesland by the average population per constituency
total_population_per_country <- total_population_per_country %>%
  mutate(DividedPopulation = round(TotalPopulation / divisor))

# Print the resulting divided population per country
print(total_population_per_country)

# Calculate and print the sum of the rounded electoral districts
total_electoral_districts <- sum(total_population_per_country$DividedPopulation)
cat("Total number of electoral districts:", total_electoral_districts, "\n")
```

We can see from the output, that several states would receive extra constituencies, while others loose constituencies. However, the total number of constituencies is 301. Since the number of electoral districts is legally fixed (299), we need to apply an algorithm that guarantees a fixed number of electoral districts.

German policy makers for this purpose use the Sainte-Lague algorithm. In the first step, this algorithm does the same calculation as the previous cell. It then checks whether the calculated number of electoral districts is equal to the fixed 299. If true, the algorithms terminates, if false, the divisor is increased or decreased until the target number is reached. The next chunk applies this algorithm while including foreigners in the avg. constituency size (the divisor).

```{r}
total_population_sum <- sum(btw_21$TotalPopulation, na.rm = TRUE)
initial_divisor <- total_population_sum / 299

# Initialize variables
divisor <- initial_divisor
total_districts <- 0

# Set a maximum number of iterations to avoid an infinite loop
max_iterations <- 1000
iterations <- 0

# Iterate until the total number of districts is 299 or the maximum number of iterations is reached
while (total_districts != 299 && iterations < max_iterations) {
  # Calculate the preliminary number of districts per country
  preliminary_districts_per_country <- btw_21 %>%
    group_by(Country) %>%
    summarise(TotalPopulation = sum(TotalPopulation, na.rm = TRUE), .groups = 'drop') %>%
    mutate(PreliminaryDistricts = round(TotalPopulation / divisor))
  
  # Update the total number of districts
  total_districts <- sum(preliminary_districts_per_country$PreliminaryDistricts)
  
  # Adjust the divisor
  if (total_districts < 299) {
    divisor <- divisor * (1 - (299 - total_districts) / 5000)
  } else if (total_districts > 299) {
    divisor <- divisor * (1 + (total_districts - 299) / 5000)
  }
  
  # Increment iteration counter
  iterations <- iterations + 1
  
  # Optional: Print intermediate results to monitor progress
  cat(sprintf("Iteration %d: Total Districts = %d, Divisor = %.2f\n", iterations, total_districts, divisor))
}

# Print the final divisor and total electoral districts to check target achievement
cat("Final iteration count:", iterations, "\n")
cat("Final Divisor:", divisor, "\n")
cat("Total Electoral Districts:", total_districts, "\n")

# Display the final distribution of districts per country
print(preliminary_districts_per_country)
```
We can see from the output, that the algorithm worked and we receive 299 constituencies in total, distributed accordingly to the total population size. We can also see, that there have been some shifts between states. Let's create a table that indiactes the old and ew distribution of constituencies and also shows the change. 

```{r}
result_df <- constituencies_per_state |> 
  left_join(preliminary_districts_per_country, by = "Country") |>
  mutate(Delta = PreliminaryDistricts - NumberOfConstituencies) |> 
  rename(CurrentNo = NumberOfConstituencies, UpdatedNo = PreliminaryDistricts) |>
  select(Country, CurrentNo, UpdatedNo, Delta)

sum_current_constituencies <- sum(result_df$CurrentNo, na.rm = TRUE)
sum_new_constituencies <- sum(result_df$UpdatedNo, na.rm = TRUE)
sum_delta <- sum(result_df$Delta, na.rm = TRUE)

# Add a summary row with the sums
result_df_summary <- result_df %>%
  add_row(Country = "Total", 
          CurrentNo = sum_current_constituencies, 
          UpdatedNo = sum_new_constituencies, 
          Delta = sum_delta)

# Print the updated dataframe with the summary row
print(result_df_summary)
```

## Berlin demographics

Next, we have detailled demographic data on the RBS-block level for Berlin. This data originally came as one csv file per constituency. Each csv file is then again separated into several sheets, one for each city district. Let's read in the data. 

```{r}
library(readxl)
library(purrr)
library(dplyr)
library(stringr)

# Directory path
directory_path <- '/Users/carlogress/Documents/GitHub/ma_thesis/Data sources/Blockdaten/'

# Define new column names in lowercase and underscores
new_columns <- c('district', 'block', 'total', 'age_below_6', 'age_6_15', 'age_15_18', 'age_18_27', 'age_27_45',
                 'age_45_55', 'age_55_65', 'age_over_65', 'migrant_background', 'foreigners', 'men')

# Get a list of all XLSX files in the directory that match the specific pattern
xlsx_files <- fs::dir_ls(path = directory_path) %>%
  str_subset("WBL-Bez\\d+-2023-06-30\\.xlsx")

# Read each file and each sheet, then concatenate into a single DataFrame
combined_df <- map_df(xlsx_files, function(file_path) {
  sheet_names <- excel_sheets(file_path)
  
  map_df(sheet_names, function(sheet) {
    read_excel(file_path, sheet = sheet, skip = 5, col_names = FALSE) %>%
      set_names(new_columns) %>%
      slice(-1) 
  }, .id = "sheet_name")
}, .id = "file_path") |> 
  filter(!is.na(block))

# Display the combined DataFrame
print(head(combined_df))

write.csv(combined_df, "Data Sources/Blockdaten/rbs_blocks_demographic.csv", row.names = FALSE)
```

The dataframe now contains the demographic information of all occupied blocks in Berlin. We can now add this demographic information to our `berlin_final` dataframe that includes the also needed spatial variables. We can achieve this by merging the two dataframes based on the block number as matching key.

```{r}
berlin_final <- berlin_final |> 
  left_join(combined_df, by = c("blknr" = "block"))
```

Let's also add a column that indiactes the share of foreigners per block: 

```{r}
berlin_final <- berlin_final |> 
  mutate(foreigners_share = foreigners / total)
```

As a test, we can also calculate the share of foreigners in each Berlin constituency: 

```{r}
berlin_final |> 
  group_by(WKR_NAME) |> 
  summarise(average_share = mean(foreigners / total, na.rm = TRUE)) |> 
  mutate(average_share = round(average_share, 2))
```
Comparing the values to the ForeignersPercentage column in the `btw21` dataframe, we can notice slight differences. These are due to recent shifts that become visible since the data come from different points in time (btw21 data from 2021, RBS block data from 2023).

```{r}
berlin_final <- st_as_sf(berlin_final, crs = utm_crs_germany)

ggplot(data = berlin_final) +
  geom_sf(aes(fill = foreigners_share), color = NA, na.value = "grey") +
  scale_fill_viridis_c(option = "plasma", name = "Foreigners Share", na.value = "grey", 
                       limits = c(NA, NA), oob = scales::squish) +
  theme_void() +
  theme(legend.position = "right")
```

Since this figure is hard to read because blocks are small, let's create a faceted plot (one for each constituency):

```{r}
library(gridExtra)

# Function to create plot for each WKR_NAME
plot_district <- function(data, district_name) {
  data %>%
    filter(WKR_NAME == district_name) %>%
    ggplot() +
    geom_sf(aes(fill = foreigners_share), color = NA, na.value = "grey") +
    scale_fill_viridis_c(name = "Foreigners Share", na.value = "grey", limits = c(NA, NA), oob = scales::squish) +
    labs(title = district_name) +
    theme_void() +
    theme(plot.title = element_text(hjust = 0.5, size = 10), legend.position = "none")
}

# Apply the function to each district
district_names <- unique(berlin_final$WKR_NAME)
plots <- lapply(district_names, function(name) plot_district(berlin_final, name))

# Combine the plots
combined_plot <- do.call(grid.arrange, c(plots, ncol = 2))

ggsave("berlin_districts_combined_plot.png", combined_plot, width = 40, height = 60, units = "cm")
```

Now we can also retrieve, whether considering foreigner while lead to some Berlin constituencies being too large or too small (based on the 25 per cen deviation rule). Earlier, we calculated the divisor (the average population size of constituencies when foreigners are included). We can now use this object to retrieve the deviation of the population sizes of the Berlin constituencies:
```{r}
sums_by_wkr <- aggregate(total ~ WKR_NAME, data = berlin_final, FUN = sum)


sums_by_wkr$deviation_share <- (sums_by_wkr$total - divisor) / divisor

# View the dataframe with the new column
print(sums_by_wkr)
```

