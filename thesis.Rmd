---
title: "Master thesis"
author: "Carlo Greß"
date: "2024-03-11"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

***********************************************************************************************************************************
# 0. Dependencies

```{r}
library(tidyverse)
library(sf)
library(sp)
library(plotly)
library(leaflet)
library(mapview)
library(tmap)
library(gridExtra)
library(kableExtra)
library(readxl)
library(redist)
```

***********************************************************************************************************************************

# 1. Spatial data files

## 1.1 Germany (Constituencies)

First, all required shapefiles need to be imported. After importing and setting an appropriate CRS, the respective maps can already be stored. These are displayed in Figure 1 of the thesis. 

```{r}
# Load the shapefile
shapefile_path <- "Data sources/btw21_geometrie_wahlkreise_vg250_geo_shp/Geometrie_Wahlkreise_20DBT_VG250_geo.shp"
wahlkreise_germany <- st_read(shapefile_path)

# UTM Zone 32N as the projected CRS for Germany
utm_crs <- "EPSG:32632"
wahlkreise_germany <- st_transform(wahlkreise_germany, crs = utm_crs)
utm_crs_germany <- st_crs(wahlkreise_germany)
```

## 1.2 Berlin (Constituencies and Electoral district borders for state elections, "Abgeordnetenhauswahl")

Shapefile for state constituencies (Abgeordnetenhaus). This is used for the redistricting simulation in the last part of the analysis.
```{r}
shapefile_path_ah_wk <- "Data sources/RBS_OD_Wahlkreise_AH2021/AWK_AH21_25833.shp"
ah_wk <- st_read(shapefile_path_ah_wk)

# Ensure the second shapefile has the same CRS as the first
if (!st_crs(ah_wk) == utm_crs_germany) {
  ah_wk <- st_transform(ah_wk, utm_crs_germany)
}

```

## 1.3 RBS-Blocks (most granular spatial level of Berlin geometry). Later used for aggregating the demographic data on the state level.
```{r}
bloecke_path <- "Data sources/rbs_bloecke_wfs/rbs_bloecke_wfs.shp"
bloecke <- st_read(bloecke_path)
bloecke <- st_transform(bloecke, utm_crs_germany)
```

## 1.4 Reading in spatially joined data (join performed in QGIS) 

RBS blocks with constituency meta informatio
```{r}
shapefile_path <- "Data sources/qgis spatial join/secondtry.shp"
rbs_ah_bt <- st_read(shapefile_path)
rbs_ah_bt <- st_transform(rbs_ah_bt, utm_crs_germany)

rbs_ah_bt_df <- as.data.frame(rbs_ah_bt)
write.csv(rbs_ah_bt_df, "Data sources/rbs_ah_bt.csv", row.names = FALSE)
```

Since the RBS and the constituency borders are not perfectly aligned, some few blocks (26 out of the 15940 blocks) have been mistakenly assigned to the wrong constituencies. The next code chunk manually corrects the flawed values. 

```{r}
berlin_final <- rbs_ah_bt_df |> 
  mutate(
    WKR_NR = case_when(
      LAND_NAME != "Berlin" & WKR_NR == 58 ~ 77,
      LAND_NAME != "Berlin" & WKR_NR == 59 ~ 85,
      LAND_NAME != "Berlin" & WKR_NR == 61 ~ 79,
      LAND_NAME != "Berlin" & WKR_NR == 62 ~ 84,
      LAND_NAME != "Berlin" & WKR_NR == 63 ~ 84,
      TRUE ~ WKR_NR
    ),
    WKR_NAME = case_when(
      LAND_NAME != "Berlin" & WKR_NR == 77 ~ "Berlin-Reinickendorf",
      LAND_NAME != "Berlin" & WKR_NR == 85 ~ "Berlin-Marzahn-Hellersdorf",
      LAND_NAME != "Berlin" & WKR_NR == 79 ~ "Berlin-Steglitz-Zehlendorf",
      LAND_NAME != "Berlin" & WKR_NR == 84 & WKR_NAME != "Berlin-Treptow-Köpenick" ~ "Berlin-Treptow-Köpenick",
      TRUE ~ WKR_NAME
    ),
    LAND_NAME = ifelse(LAND_NAME != "Berlin", "Berlin", LAND_NAME),
    LAND_NR = ifelse(LAND_NAME == "Berlin", as.numeric(11), LAND_NR)
  )

berlin_final <- berlin_final |> 
  mutate( 
    WKR_NR = case_when(blknr == 171601 ~ 76,
    TRUE ~ WKR_NR),
    WKR_NAME = case_when(blknr == 171601  ~ "Berlin-Pankow",
    TRUE ~ WKR_NAME)
    )
```

## 1.5 Plots for Figure 1 and 2

Federal Constituencies
```{r}
g <- ggplot() +
  geom_sf(data = wahlkreise_germany, fill = "white", color = "black", linewidth = 1.5) +
  labs(x = NULL, y = NULL) + # Remove axis titles
  theme_void() + # This removes background, gridlines, and text
  theme(plot.title = element_text(hjust = 0.5)) # Center the title

ggsave("final_figures/figure 1/wahlkreise_germany_map_large.png", plot = g, width = 16, height = 12, dpi = 300)
```

Berlin constituencies 
```{r}
g <- wahlkreise_germany |> 
  filter(LAND_NAME == "Berlin") |> 
  ggplot() +
  geom_sf(fill = "white", color = "black", linewidth = 1.5) +
  theme_void() 

ggsave("final_figures/figure 1/wahlkreise_berlin.png", plot = g, width = 16, height = 12, dpi = 300)
ggsave("final_figures/figure 2/wahlkreise_berlin.png", plot = g, width = 16, height = 12, dpi = 300)
```

Berlin state constituencies
```{r}
g <- ggplot() +
  geom_sf(data = ah_wk, fill = "white", color = "black", linewidth = 1.5) +
  theme_void()

ggsave("final_figures/figure 2/ah_wk_map_large.png", plot = g, width = 16, height = 12, dpi = 300)
```

Berlin RBS-blocks
```{r}
g <- ggplot() +
  geom_sf(data = bloecke, fill = "white", color = "black") +
  theme_void() 

ggsave("final_figures/figure 2/bloecke_map_large.png", plot = g, width = 16, height = 12, dpi = 300)
```

Finding the geographically largest and smallest constituency (used in Section 4.1 on constituency data)

```{r}
# Calculate area in square kilometers
wahlkreise_germany <- wahlkreise_germany |>
  mutate(area_km2 = st_area(geometry) / 10^6)  # st_area() results are in square meters; convert to square kilometers

# Find the constituencies with the largest and smallest area
largest_area <- wahlkreise_germany[which.max(wahlkreise_germany$area_km2), ]
smallest_area <- wahlkreise_germany[which.min(wahlkreise_germany$area_km2), ]

# Display the WKR_NAME and area of the largest and smallest constituencies
cat("Largest Area Constituency:\n")
print(largest_area[, c("WKR_NAME", "area_km2")])

cat("\nSmallest Area Constituency:\n")
print(smallest_area[, c("WKR_NAME", "area_km2")])
```

***********************************************************************************************************************************
# 2. Demographic data

## 2.1 Germany (Data Source: Bundeswahlleiterin)

The next chunk imports the demographic data for the 299 federal constituencies in Germany (2021). Before working with the data, several adjustments are necessary: Changing the notation (in the original data, thousands have been indicated by dots and decimals by commas). Additionally, only demographic variables are kept and renamed. Some variables have been measured in thousands (area and population). These variables are multiplied by 1000 to receive the real values. Lastly, only the rows containing information on the constituncies are kept (they can be identified based on the constituency ID `DistrictNo`)
```{r}
csv_file_path <- "Data sources/bundestagswahlkreise/btw21_strukturdaten.csv"

# Define the locale with German notation
german_locale <- locale(decimal_mark = ",", grouping_mark = ".")

# Load the CSV file
btw_21 <- read_delim(csv_file_path, delim = ';', skip = 8, col_names = TRUE, locale = german_locale)

# Keep demographic variables only 
btw_21 <- btw_21 |> 
  dplyr::select(1:17)

# Rename the columns
btw_21 <- btw_21 |> 
  rename(
    Country = `Land`,
    DistrictNo = `Wahlkreis-Nr.`,
    DistrictName = `Wahlkreis-Name`,
    Municipalities = `Gemeinden am 31.12.2019 (Anzahl)`,
    Area = `Fläche am 31.12.2019 (km²)`,
    TotalPopulation = `Bevölkerung am 31.12.2019 - Insgesamt (in 1000)`,
    GermanPopulation = `Bevölkerung am 31.12.2019 - Deutsche (in 1000)`,
    ForeignersPercentage = `Bevölkerung am 31.12.2019 - Ausländer/-innen (%)`,
    PopulationDensity = `Bevölkerungsdichte am 31.12.2019 (EW je km²)`,
    BirthRate = `Zu- (+) bzw. Abnahme (-) der Bevölkerung 2019 - Geburtensaldo (je 1000 EW)`,
    MigrationRate = `Zu- (+) bzw. Abnahme (-) der Bevölkerung 2019 - Wanderungssaldo (je 1000 EW)`,
    Age_Under18 = `Alter von ... bis ... Jahren am 31.12.2019 - unter 18 (%)`,
    Age_18_24 = `Alter von ... bis ... Jahren am 31.12.2019 - 18-24 (%)`,
    Age_25_34 = `Alter von ... bis ... Jahren am 31.12.2019 - 25-34 (%)`,
    Age_35_59 = `Alter von ... bis ... Jahren am 31.12.2019 - 35-59 (%)`,
    Age_60_74 = `Alter von ... bis ... Jahren am 31.12.2019 - 60-74 (%)`,
    Age_75plus = `Alter von ... bis ... Jahren am 31.12.2019 - 75 und mehr (%)`
  )

# Adjust 'Area', 'TotalPopulation', and 'GermanPopulation' by multiplying by 1000 (original data was measured in thousands)
btw_21 <- btw_21 |> 
  mutate(Area = Area * 1000,
         TotalPopulation = TotalPopulation * 1000,
         GermanPopulation = GermanPopulation * 1000) |> 
  # Filter rows where 'DistrictNo' is less than or equal to 299. This effectively means to only consider the real constituency rows, not any cumulative measures
  filter(DistrictNo <= 299)
```

The next chunk calculates the average total and German population and share of foreigners per constituency.
```{r}
# Calculate average values
average_total_population <- mean(btw_21$TotalPopulation, na.rm = TRUE)
average_german_population <- mean(btw_21$GermanPopulation, na.rm = TRUE)
average_foreigners_percentage <- mean(btw_21$ForeignersPercentage, na.rm = TRUE)

# Print the results
cat("Average Total Population:", sprintf("%.2f", average_total_population), "\n")
cat("Average German Population:", sprintf("%.2f", average_german_population), "\n")
cat("Average Foreigners Percentage:", sprintf("%.2f", average_foreigners_percentage), "\n")
```

### Figure 3

Figure 3 consists of six distinct plots: It shows (a) the deviation from the average constituency population size for each constituency, (b) the constituencies with deviation values above 15 %, an (c) the constituencies with deviation values above 25 %. Each of these maps is created for (1) only the German population and (2) the total population including foreigner.

First, a new variable that indicates the deviation of the German population from the average German population as a share is created in the next chunk. This information is required for `Figure 3`. Additionally, we add the geometry of the constituencies in order to be able to plot the later results. For that purpose, we can use the `wahlkreise_germany` object. The resulting dataframe `btw_21` contains the demographic and the spatial information.

```{r}
btw_21 <- btw_21 |> 
  mutate(deviation = (GermanPopulation - average_german_population) / average_german_population * 100)

# Adjust btw_21 by removing leading zeros from DistrictNo
btw_21 <- btw_21 |>
  mutate(DistrictNo = as.numeric(as.character(DistrictNo)))

btw_21 <- btw_21 |>
  left_join(wahlkreise_germany |> select(WKR_NR, geometry), by = c("DistrictNo" = "WKR_NR"))

btw_21_sf <- st_as_sf(btw_21, crs = st_crs(utm_crs_germany))
```

Next, we will create a plot that shows how much the constituencies deviate from the average population number (we will set the min/max values to the deviation values including foreigners. This is done to achieve a comparable color scaling later). The plots generated by the following chunks are displayed in Figure 3. 

```{r}
btw_21_sf <- btw_21_sf |> 
  mutate(deviation_non_residents = (TotalPopulation - average_total_population) / average_total_population * 100)

btw_21_sf <- st_as_sf(btw_21_sf)

ggplot(data = btw_21_sf) +
  geom_sf(aes(fill = deviation), color = "0.8", size = 0.8) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in %)", limits = c(min(btw_21_sf$deviation_non_residents, na.rm = TRUE), max(btw_21_sf$deviation_non_residents, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.position = "none")

ggsave("final_figures/figure 3/population_deviation_map.png", width = 12, height = 8, dpi = 300)

```

Now, I am creating a similar plot that only shows the constituencies that have a deviation of below -15 % or above 15 %. These constituencies should, when possible, be redistricted. 
```{r}
btw_21_sf <- btw_21_sf |> 
  mutate(deviation15 = ifelse(deviation < -15 | deviation > 15, 1, 0))

# Plot all constituencies, coloring by deviation value or grey if not significant
ggplot(data = btw_21_sf) +
  geom_sf(data = btw_21_sf |> filter(deviation15 == 0), fill = "grey", color = NA, size = 0.1) +
  geom_sf(data = btw_21_sf |> filter(deviation15 == 1), aes(fill = deviation), color = NA, size = 0.1) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in per cent)", 
                       limits = c(min(btw_21_sf$deviation_non_residents, na.rm = TRUE), max(btw_21_sf$deviation_non_residents, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.position = "none")

ggsave("final_figures/figure 3/deviation15.png", width = 12, height = 8, dpi = 300)
```
Deviation -25/25
```{r}
btw_21_sf <- btw_21_sf |> 
  mutate(deviation25 = ifelse(deviation < -25 | deviation > 25, 1, 0))

# Plot all constituencies, coloring by deviation value or grey if not significant
ggplot(data = btw_21_sf) +
  geom_sf(data = btw_21_sf |> filter(deviation25 == 0), fill = "grey", color = NA, size = 0.1) +
  geom_sf(data = btw_21_sf |> filter(deviation25 == 1), aes(fill = deviation), color = NA, size = 0.1) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in per cent)", 
                       limits = c(min(btw_21_sf$deviation_non_residents, na.rm = TRUE), max(btw_21_sf$deviation_non_residents, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.position = "none")

ggsave("final_figures/figure 3/deviation25.png", width = 12, height = 8, dpi = 300)
```

Let's briefly check the minimum and maximum values of deviation as well as the number of constituencies with such a deviation. If a constituency falls below -25 or above 25 per cent deviation, it needs to be redistricted (mandatory).

```{r}
btw_21_sf |> 
  filter(deviation15 == 1) |> 
  length()

cat("District with min. deviation:", btw_21_sf$DistrictName[which.min(btw_21_sf$deviation)], sprintf("(%.2f)", min(btw_21_sf$deviation)), "\n")
cat("District with max. deviation:", btw_21_sf$DistrictName[which.max(btw_21_sf$deviation)], sprintf("(%.2f)", max(btw_21_sf$deviation)), "\n")
```

Map that shows the deviation including foreign residents: 
```{r}
ggplot(data = btw_21_sf) +
  geom_sf(aes(fill = deviation_non_residents), color = "0.8", size = 0.8) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in %)", limits = c(min(btw_21_sf$deviation_non_residents, na.rm = TRUE), max(btw_21_sf$deviation_non_residents, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12)) +
  theme(legend.position = "none")

ggsave("final_figures/figure 3/deviation_nr.png", width = 12, height = 8, dpi = 300)
```
Map that shows deviation incl. foreign residents but only highlighting constituencies with below -15 % / above 15 % deviation

```{r}
btw_21_sf <- btw_21_sf |> 
  mutate(deviation15_nr = ifelse(deviation_non_residents < -15 | deviation_non_residents > 15, 1, 0))

# Plot all constituencies, coloring by deviation value or grey if not significant
ggplot(data = btw_21_sf) +
  geom_sf(data = btw_21_sf |> filter(deviation15_nr == 0), fill = "grey", color = NA, size = 0.1) +
  geom_sf(data = btw_21_sf |> filter(deviation15_nr == 1), aes(fill = deviation_non_residents), color = NA, size = 0.1) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in per cent)", 
                       limits = c(min(btw_21_sf$deviation_non_residents, na.rm = TRUE), max(btw_21_sf$deviation_non_residents, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.position = "none")

ggsave("final_figures/figure 3/deviation15_nr.png", width = 12, height = 8, dpi = 300)
```

Map that shows deviation incl. foreign residents but only highlighting constituencies with below -25 % / above 25 % deviation

```{r}
btw_21_sf <- btw_21_sf |> 
  mutate(deviation25_nr = ifelse(deviation_non_residents < -25 | deviation_non_residents > 25, 1, 0))

# Plot all constituencies, coloring by deviation value or grey if not significant
ggplot(data = btw_21_sf) +
  geom_sf(data = btw_21_sf |> filter(deviation25_nr == 0), fill = "grey", color = NA, size = 0.1) +
  geom_sf(data = btw_21_sf |> filter(deviation25_nr == 1), aes(fill = deviation_non_residents), color = NA, size = 0.1) +
  scale_fill_distiller(palette = "RdBu", name = "Deviation (in per cent)", 
                       limits = c(min(btw_21_sf$deviation_non_residents, na.rm = TRUE), max(btw_21_sf$deviation_non_residents, na.rm = TRUE))) +
  theme_void() +
  theme(plot.title = element_text(size = 16),
        axis.title.x = element_text(size = 12),
        axis.title.y = element_text(size = 12),
        legend.position = "none")

ggsave("final_figures/figure 3/deviation25_nr.png", width = 12, height = 8, dpi = 300)
```

### Table 1

Calculate how many constituencies are deviating by more than 15/25 percent. 
```{r}
# Excluding foreigners
nrow(btw_21_sf |> filter(deviation15 == 1))
nrow(btw_21_sf |> filter(deviation25 == 1))
cat("Average German Population:", sprintf("%.2f", average_german_population), "\n")

# Including foreigners
nrow(btw_21_sf |> filter(deviation15_nr == 1))
nrow(btw_21_sf |> filter(deviation25_nr == 1))
cat("Average Total Population:", sprintf("%.2f", average_total_population), "\n")
```
### Figure 4

Ultimately, we create a plot that shows the distribution of the deviation values for all 299 constituencies. Again, we create separate plots for both the German and the total population in order to highlight the differences. Moreover, we add vertical lines for indicating no deviation, 15 per cent deviation, and 25 per cent deviation, since these numbers are relevant within the respective legislation (15 per cent: Redistricting recommended, 25 per cent: Redistricting mandatory).

```{r}
btw21_df <- as.data.frame(btw_21_sf)

# Reshaping the data to a long format
btw21_long <- btw21_df |>
  select(deviation, deviation_non_residents) |>
  pivot_longer(cols = everything(), names_to = "variable", values_to = "value")

# Ensure values are integers
btw21_long$value <- round(btw21_long$value)

ggplot(btw21_long, aes(x = value, fill = variable)) +
  geom_histogram(binwidth = 2, alpha = 0.7, position = "dodge", color = "black") +
  facet_wrap(~ variable, scales = "fixed", ncol = 1, labeller = labeller(variable = c(deviation = "German Population", deviation_non_residents = "Population incl. Foreigners"))) +
  theme_minimal(base_size = 14) +
  theme(panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        legend.position = "none",
        axis.text.x = element_text(angle = 45, hjust = 1),
        panel.border = element_rect(colour = "black", fill=NA, size=0.5),
        strip.text = element_text(size = 16, face = "bold")) +  # Increased size and bold text for facet labels
  geom_vline(xintercept = 0, linetype = "dashed", color = "black", size = 0.5) +
  geom_vline(xintercept = 15, linetype = "dashed", color = "red", size = 0.5) +
  geom_vline(xintercept = -15, linetype = "dashed", color = "red", size = 0.5) +
  geom_vline(xintercept = 25, linetype = "solid", color = "red", size = 0.5) +
  geom_vline(xintercept = -25, linetype = "solid", color = "red", size = 0.5) +
  scale_x_continuous(breaks = seq(from = floor(min(btw21_long$value)), to = ceiling(max(btw21_long$value)), by = 5)) +
  scale_y_continuous(labels = function(x) format(x, scientific = FALSE)) +
  labs(y = "Frequency", x = "Deviation (%)")

ggsave("final_figures/figure 4/distribution_deviation.png", width = 12, height = 8, dpi = 300)
```
Foreigners Share by State (referenced in Section 6: Analysis) and Appendix

```{r}
table_latex <- btw_21 %>%
  group_by(Country) %>%
  summarise(
    TotalSumPopulation = sum(TotalPopulation, na.rm = TRUE),
    GermanSumPopulation = sum(GermanPopulation, na.rm = TRUE)
  ) %>%
  mutate(MeanForeignersPercentage = round((TotalSumPopulation - GermanSumPopulation) / TotalSumPopulation * 100, 2)) %>%
  select(Country, MeanForeignersPercentage) %>%
  arrange(MeanForeignersPercentage) %>%
  kable("latex", booktabs = TRUE) %>%
  kable_styling(latex_options = c("striped", "scale_down"))

save_kable(table_latex, file = "tables/foreigners_share.tex")
```

### Table 2

Table 2 compares how many constituencies are currently allocated to each federal state (Bundesland) and how many constituencies each federal state should receive if foreign residents would be counted. 

First, the average population sizes of constituencies with and without foreigners as well as how many constituencies are assigned to each federal state under the current legislation are calculated. 

```{r}
average_german_population_per_row <- round(mean(btw_21$GermanPopulation, na.rm = TRUE))

# Calculate the average Total Population
average_total_population <- round(mean(btw_21$TotalPopulation, na.rm = TRUE))

# Calculate the current number of constituencies per state
constituencies_per_state <- btw_21 |>
  group_by(Country) |>
  summarise(NumberOfConstituencies = n())

cat("Average German Population:", sprintf("%.2f", average_german_population_per_row), "\n")
cat("Average Total Population:", sprintf("%.2f", average_total_population), "\n")
cat("Current number of constituencies per state:\n")
print(constituencies_per_state)

# As we can see from the output, considering foreigners increases the average population size per constituency by almost 35,000 inhabitants, from 243,373 to 278,148. Furthermore, we can derive that Nordrhein-Westfalen has the highest number of electoral districts (64), while Bremen only has 2. 
```

Next, we want to calculate how many constituencies each state should receive when foreigner considered. In the last chunk, we already calculated the avg. population size including foreigners. 

```{r}
divisor <- mean(btw_21$TotalPopulation, na.rm = TRUE)

# Sum total population per state (Bundesland)
total_population_per_country <- btw_21 |>
  group_by(Country) |>
  summarise(TotalPopulation = sum(TotalPopulation, na.rm = TRUE)) |>
  ungroup()

# Divide the total population of each Bundesland by the average population per constituency
total_population_per_country <- total_population_per_country |>
  mutate(DividedPopulation = round(TotalPopulation / divisor))

print(total_population_per_country)

total_electoral_districts <- sum(total_population_per_country$DividedPopulation)
cat("Total number of electoral districts:", total_electoral_districts, "\n")
```

We can see from the output, that several states would receive extra constituencies, while others loose constituencies. However, the total number of constituencies is 301. Since the number of electoral districts is legally fixed (299), we need to apply an algorithm that guarantees a fixed number of electoral districts.

German policy makers for this purpose use the Sainte-Lague algorithm. In the first step, this algorithm does the same calculation as the previous cell. It then checks whether the calculated number of electoral districts is equal to the fixed 299. If true, the algorithms terminates, if false, the divisor is increased or decreased until the target number is reached. The next chunk applies this algorithm while including foreigners in the avg. constituency size (the divisor).

#### Saint Laguë algorithm implementation

```{r}
total_population_sum <- sum(btw_21$TotalPopulation, na.rm = TRUE)
initial_divisor <- total_population_sum / 299

# Initialize variables
divisor <- initial_divisor
total_districts <- 0

# Set a maximum number of iterations to avoid an infinite loop
max_iterations <- 1000
iterations <- 0

# Iterate until the total number of districts is 299 or the maximum number of iterations is reached
while (total_districts != 299 && iterations < max_iterations) {
  # Calculate the preliminary number of districts per country
  preliminary_districts_per_country <- btw_21 |>
    group_by(Country) |>
    summarise(TotalPopulation = sum(TotalPopulation, na.rm = TRUE), .groups = 'drop') |>
    mutate(PreliminaryDistricts = round(TotalPopulation / divisor))
  
  # Update the total number of districts
  total_districts <- sum(preliminary_districts_per_country$PreliminaryDistricts)
  
  # Adjust the divisor
  if (total_districts < 299) {
    divisor <- divisor * (1 - (299 - total_districts) / 5000)
  } else if (total_districts > 299) {
    divisor <- divisor * (1 + (total_districts - 299) / 5000)
  }
  
  # Increment iteration counter
  iterations <- iterations + 1
  
  cat(sprintf("Iteration %d: Total Districts = %d, Divisor = %.2f\n", iterations, total_districts, divisor))
}


cat("Final iteration count:", iterations, "\n")
cat("Final Divisor:", divisor, "\n")
cat("Total Electoral Districts:", total_districts, "\n")


print(preliminary_districts_per_country)
```
We can see from the output, that the algorithm worked and we receive 299 constituencies in total, distributed accordingly to the total population size. We can also see, that there have been some shifts between states. Let's create a table that indicates the old and new distribution of constituencies and also shows the change. 

```{r}

result_df <- constituencies_per_state |> 
  left_join(preliminary_districts_per_country, by = "Country") |>
  mutate(Delta = PreliminaryDistricts - NumberOfConstituencies) |> 
  rename(CurrentNo = NumberOfConstituencies, UpdatedNo = PreliminaryDistricts) |>
  select(Country, CurrentNo, UpdatedNo, Delta)

sum_current_constituencies <- sum(result_df$CurrentNo, na.rm = TRUE)
sum_new_constituencies <- sum(result_df$UpdatedNo, na.rm = TRUE)
sum_delta <- sum(result_df$Delta, na.rm = TRUE)

# Add a summary row with the sums
result_df_summary <- result_df |>
  add_row(Country = "Total", 
          CurrentNo = sum_current_constituencies, 
          UpdatedNo = sum_new_constituencies, 
          Delta = sum_delta)

print(result_df_summary)

latex_table <- result_df_summary |>
  kable("latex", booktabs = TRUE) |> 
  kable_styling(latex_options = c("striped", "scale_down"))

writeLines(as.character(latex_table), "tables/constituenciy_allocation.tex")
```

## 2.1 Berlin demographics

Next, we have detailed demographic data on the RBS-block level for Berlin. This data originally came as one csv file per constituency. Each csv file is then again separated into several sheets, one for each city district. Let's read in the data, renaming the columns and skipping rows that do not contain information. 

```{r}

directory_path <- '/Users/carlogress/Documents/GitHub/ma_thesis/Data sources/Blockdaten/'

# Define new column names in lowercase and underscores
new_columns <- c('district', 'block', 'total', 'age_below_6', 'age_6_15', 'age_15_18', 'age_18_27', 'age_27_45',
                 'age_45_55', 'age_55_65', 'age_over_65', 'migrant_background', 'foreigners', 'men')

# Get a list of all XLSX files in the directory that match the specific pattern
xlsx_files <- fs::dir_ls(path = directory_path) |>
  str_subset("WBL-Bez\\d+-2023-06-30\\.xlsx")

# Read each file and each sheet, then concatenate into a single DataFrame
combined_df <- map_df(xlsx_files, function(file_path) {
  sheet_names <- excel_sheets(file_path)
  
  map_df(sheet_names, function(sheet) {
    read_excel(file_path, sheet = sheet, skip = 5, col_names = FALSE) |>
      set_names(new_columns) |>
      slice(-1) 
  }, .id = "sheet_name")
}, .id = "file_path") |>  
  filter(!is.na(block))


print(head(combined_df))

write.csv(combined_df, "Data Sources/Blockdaten/rbs_blocks_demographic.csv", row.names = FALSE)
```

The dataframe now contains the demographic information of all occupied blocks in Berlin. We can now add this demographic information to our `berlin_final` dataframe that includes the also needed spatial variables. We can achieve this by merging the two dataframes based on the block number as matching key.

```{r}
berlin_final <- berlin_final |> 
  left_join(combined_df, by = c("blknr" = "block"))
```

Let's also add a column that indicates the share of foreigners per block: 

```{r}
berlin_final <- berlin_final |> 
  mutate(foreigners_share = foreigners / total)
```

As a test, we can also calculate the share of foreigners in each Berlin constituency: 

```{r}
berlin_final |> 
  group_by(WKR_NAME) |> 
  summarise(average_share = mean(foreigners / total, na.rm = TRUE)) |> 
  mutate(average_share = round(average_share, 2))
```
Comparing the values to the ForeignersPercentage column in the `btw21` dataframe, we can notice slight differences. These are due to recent shifts that become visible since the data come from different points in time (btw21 data from 2021, RBS block data from 2023).

Now, we can also retrieve whether considering foreigners will lead to some Berlin constituencies being too large or too small (based on the 25 per cent deviation rule). Earlier, we calculated the divisor (the average population size of constituencies when foreigners are included). We can now use this object to retrieve the deviation of the population sizes of the Berlin constituencies:
```{r}
sums_by_wkr <- aggregate(total ~ WKR_NAME, data = berlin_final, FUN = sum)

sums_by_wkr$deviation_share <- (sums_by_wkr$total - divisor) / divisor

print(sums_by_wkr)
```
### Table 3

Let's compare the population and deviation values with the currently used values where foreigners are not considered: 
```{r}
avg_population_per_district <- mean(btw_21$GermanPopulation, na.rm = TRUE)

sums_by_wkr_prepared <- sums_by_wkr |>
  rename(WKR_NAME = WKR_NAME,
         population_new = total,
         deviation_new = deviation_share) |>
  mutate(deviation_new = round(deviation_new, 2))  

btw21_prepared <- btw_21 |>
  mutate(deviation_old = (GermanPopulation - avg_population_per_district) / avg_population_per_district,
         deviation_old = round(deviation_old, 2)) |>  
  rename(DistrictName = DistrictName,
         population_old = GermanPopulation)

combined_table <- sums_by_wkr_prepared |>
  left_join(btw21_prepared, by = c("WKR_NAME" = "DistrictName"))

final_table <- combined_table |>
  select(WKR_NAME, population_new, deviation_new, population_old, deviation_old) |> 
  arrange(desc(deviation_new))

print(final_table)
```
```{r}
library(knitr)
library(kableExtra)

latex_table <- final_table |>
  kable("latex", booktabs = TRUE) |> 
  kable_styling(latex_options = c("striped", "scale_down"))

writeLines(as.character(latex_table), "tables/pop_deviation_berlin.tex")
```

***********************************************************************************************************************************
# 3. Redistricting simulation

As we saw in the previous calculation, considering foreigners in the Berlin constituencies leads to significant deviations from the average population size. Concretely, two districts *should* - if possible - redistricted since their deviation from the average exceeds 15 per cent (Neukölln: + 18 %; Pankow: + 24 %). More importantly, there are now three districts where redistricting would be *mandatory* due to a deviation of more than 25 per cent: Tempelhof-Schöneberg (+ 27 %), Friedrichshain-Kreuzberg-Prenzlauer Berg Ost (+ 33 %) and Mitte (+ 42 %). Additionally, we calculated earlier how many constituencies each German state should receive, showing that Berlin would receive a new, thirteenth district. Hence, the next task is to propose a redistricting simulation that (a) introduces a new district  and (b) similarly resolves the problem of the three overpopulated districts. 

We are using the `redist` library in order to propose a redistricting scheme.

## 3.1 Data Preparation


Two (unoccupied) blocks have been assigned to the wrong AWK during the spatial join. Similarly, some state constituencies have been assigned to more than one federal constituencies, since the borders are not always congruent. The next chunk corrects the flawed allocation and checks which state constituencies are allocated to more than one federal constituency.

```{r}
berlin_final <- berlin_final |> 
  mutate(
    WKR_NR = case_when(
      blknr == 106900 ~ 76,
      blknr == 116086 ~ 86,
      TRUE ~ WKR_NR
    ),
    WKR_NAME = case_when(
      blknr == 106900 ~ "Berlin-Pankow",
      blknr == 116086 ~ "Berlin-Lichtenberg",
      TRUE ~ WKR_NAME
    )
  )

filter(berlin_final, blknr %in% c(106900, 116086))

# Now, let's explore which AWKs have more than one assigned federal constituency:

awk_with_multiple_wkrs <- berlin_final |>
  group_by(AWK) |>
  summarise(num_WKR_NR = n_distinct(WKR_NR)) |>
  filter(num_WKR_NR > 1) |>
  arrange(AWK) 

# Print AWKs allocated to more than one WKR_NR, one row per AWK
print(awk_with_multiple_wkrs)
```
The next chunk flags the state constituencies that are assigned to more than one federal constituency.

```{r}
berlin_final <- berlin_final |>
  mutate(AWK = as.factor(AWK), WKR_NR = as.factor(WKR_NR)) |>
  group_by(AWK) |>
  mutate(WKR_NR_count = n_distinct(WKR_NR)) |>
  ungroup()

# Assigning each WKR_NR within each AWK a sequence number
berlin_final <- berlin_final |>
  group_by(AWK) |>
  mutate(WKR_NR_seq = as.integer(factor(WKR_NR, levels = unique(WKR_NR)))) |>
  ungroup()

# Converting sequence numbers to letters and creating modified AWK codes
berlin_final <- berlin_final |>
  mutate(AWK_mod = if_else(WKR_NR_count > 1, 
                           paste0(AWK, "_", letters[WKR_NR_seq]), 
                           as.character(AWK)))

# Aggregating data based on AWK_mod, WKR_NR, and WKR_NAME
aggregated_data <- berlin_final |>
  group_by(AWK_mod, WKR_NR, WKR_NAME) |>
  summarise(
    total_population = sum(total, na.rm = TRUE),
    foreign_population = sum(foreigners, na.rm = T),
    geometry = sf::st_union(geometry),
    .groups = 'drop'
  )

# Inspect the result
print(head(aggregated_data))
```

Now, we are (almost) ready for redistricting based on the electoral districts of the Abgeordnetenhaus (which is one administrative level below the Federal Constituencies). There is, however, one issue: In the original data (RBS blocks), directly neighboring blocks are not always spatially contingent since they are separated by streets. This, however, is necessary to be able to use the redist package. Since the neighboring blocks are not even touching, it is not possible to use st_union in order to combine blocks to the AWK districts. Hence, I am using a little workaround: After aggregating the population figures per AWK district, I can import the official geometry for these districts and simply add the population figures. As a result, I am receiving a sf object including all necessary (unionized) districts and the corresponding population. Additionally, I can add the corresponding Federal constituency to each AWK district. The only limitation with this approach is that four of the 78 AWK districts in which the borders do not match the higher level constituency border perfectly (hence, one AWK district is split between two constituencies - we flagged these in the chunk before). In these four cases, I will manually assign the part of the AWK with the lower population to the constituency of the other part.

```{r}

# Manually assigning split AWK districts to only one Federal constituency (this includes assigning two split districts entirely to Pankow, one to Friedrichshain-Kreuzberg – Prenzlauer Berg Ost and one to Berlin-Spandau – Charlottenburg Nord)

awk_aggregated_data <- as.data.frame(aggregated_data)
awk_aggregated_data <- select(awk_aggregated_data, -geometry)

awk_aggregated_data <- awk_aggregated_data |>
  mutate(
    group_id = case_when(
      str_starts(AWK_mod, "0307") ~ "0307",
      str_starts(AWK_mod, "0308") ~ "0308",
      str_starts(AWK_mod, "0309") ~ "0309",
      str_starts(AWK_mod, "0401") ~ "0401",
      TRUE ~ AWK_mod
    )
  ) |>
  group_by(group_id) |>
  summarise(
    total_population = sum(total_population, na.rm = TRUE),
    foreign_population = sum(foreign_population, na.rm = T),
    WKR_NR = case_when(
      group_id %in% c("0307", "0308") ~ "76",
      group_id == "0309" ~ "83",
      group_id == "0401" ~ "78",
      TRUE ~ WKR_NR 
    ),
    WKR_NAME = case_when(
      group_id %in% c("0307", "0308") ~ "Berlin-Pankow",
      group_id == "0309" ~ "Berlin-Friedrichshain-Kreuzberg – Prenzlauer Berg Ost",
      group_id == "0401" ~ "Berlin-Spandau – Charlottenburg Nord",
      TRUE ~ WKR_NAME  
    ),
    .groups = 'drop'
  )

awk_aggregated_data <- distinct(awk_aggregated_data)
```
Ultimately, we can join the prepared demographic data and the state constituency geometry. 
```{r}
shapefile_path_ah_wk <- "Data sources/RBS_OD_Wahlkreise_AH2021/AWK_AH21_25833.shp"
ah_wk <- st_read(shapefile_path_ah_wk)

# Ensure the second shapefile has the same CRS as the first
if (!st_crs(ah_wk) == utm_crs_germany) {
  ah_wk <- st_transform(ah_wk, utm_crs_germany)
}

ah_wk <- ah_wk |>
  left_join(awk_aggregated_data, by = c("AWK" = "group_id"))

ah_wk<- ah_wk |> 
  mutate(german_pop = total_population - foreign_population)
```
## 3.2 Simulation

The next prompt creates a new dataframe and makes sure that a thirteenth district is added by settint `ndists` = 13. Additionally, we add the population tolerance of 25 %. However, one minor issue arises here: the pop_tol argument takes the values from the total_population as baseline. However, we must acknowledge that most of the Berlin districts have already higher populatino figures than the Germany-wide average. Thus, a deviation of 25 % Berlin-wide would lead to a deviation of more than 25 % Germany-wide. Thus, we additionally specify population bounds, where the target is the nation-wide average per constituency, and the lower and upper bound are the 25 % deviations from that target value. 

```{r}

set.seed(123)

# Calculating lower and upper population bounds. Target is already stored in the divisor object. 

lower <- divisor * 0.75
upper <- divisor * 1.25

berlin_redist <- redist_map(ah_wk, ndists = 13, pop_tol = 0.25, total_pop = total_population, pop_bounds =  c(lower, divisor, upper))

```

Running the simulation:
```{r}
berlin_plans = redist_smc(berlin_redist, nsims=500, counties = WKR_NAME, compactness = 1, runs = 2)
```

### Figure 5

Figure 5 plots six of the simulated plans. However, it would be not appropriate to display six random draws. We should rather look at specific draws that are interesting due to some specifications. Here, I decided to look at the 6 draws that have the *minimum mean absolute population deviation across constituencies*. 

```{r}
berlin_plans$pop_deviation <- ((berlin_plans$total_pop - divisor) / divisor) 

berlin_plans$draw <- as.factor(berlin_plans$draw)

top_draws <- berlin_plans |>
  group_by(draw) |>
  summarise(mean_abs_pop_deviation = mean(abs(pop_deviation), na.rm = TRUE)) |>
  arrange(mean_abs_pop_deviation)

png(filename = "final_figures/figure 5/simulations_deviations.png", width = 12, height = 8, units = "in", res = 300)

redist.plot.plans(top_draws, draws = 1:6, shp = berlin_redist)

dev.off()
```

### Figure 6

Distribution of mean absolute deviation from the average constituency size
```{r}

mean_abs_dev <- berlin_plans |>
  group_by(draw) |>
  summarise(mean_abs_dev = mean(abs(pop_deviation), na.rm = TRUE)) |>
  ungroup()  # This step is to remove the grouping structure for plotting

# Calculate the mean of mean absolute deviations
mean_value <- mean(mean_abs_dev$mean_abs_dev, na.rm = TRUE)

# Plotting
ggplot(mean_abs_dev, aes(x = mean_abs_dev)) +
  geom_histogram(binwidth = 0.003, color = "black", fill = "gray", alpha = 0.7) +
  labs(x = "Mean Absolute Deviation", y = "Frequency") +  
  theme_minimal() +
  theme(panel.grid.major = element_blank(),   
        panel.grid.minor = element_blank(),   
        plot.title = element_blank(),   
        axis.title.x = element_text(size = 14, face = "bold"),  
        axis.title.y = element_text(size = 14, face = "bold"),  
        axis.text = element_text(size = 12),  
        plot.background = element_blank(),    
        panel.border = element_rect(colour = "black", fill = NA, size = 1))

# Save the plot
ggsave("final_figures/figure 6/deviation_hist.png", width = 12, height = 8, dpi = 300)

```

### Figure 7

In order to find the optimal plan, we can also create another simulation that adheres to a tighter population deviation limit of 15 per cent. This could be interesting for policy makers since constituencies were less likely to exceed the 25 per cent limit in the near future. Additionally, we might want to assure that the absolute number of German per constituency is relatively equal. The next chunk therefore sets tighter upper and lower limits, runs the same simulation as before (only aiming for higher compactness, so that an improved population balance is not achieved to worse compactness), and calculates the share and absolute number of the German population.
```{r}
set.seed(123)

lower <- divisor * 0.85
upper <- divisor * 1.15

berlin_redist_15 <- redist_map(ah_wk, ndists = 13, pop_tol = 0.15, total_pop = total_population, pop_bounds =  c(lower, divisor, upper))

berlin_plans_15 = redist_smc(berlin_redist_15, nsims=500, counties = WKR_NAME, compactness = 1.5, runs = 2)


berlin_plans_15$german_share <- group_frac(berlin_redist_15,
           german_pop,
           total_population,
           berlin_plans)

berlin_plans_15$foreigners_share <- group_frac(berlin_redist_15,
           foreign_population,
           total_population,
           berlin_plans)

berlin_plans_15 <- berlin_plans_15 |> 
  mutate(german_pop = total_pop * german_share)

berlin_plans_15$pop_deviation <- ((berlin_plans_15$total_pop - divisor) / divisor)
```

Ultimately, the resulting simulation plans are ordered based on the standard deviation of the variable capturing the absolute number of Germans per constituency. 
```{r}

std_dev_filtered_draws <- berlin_plans_15 %>%
  group_by(draw) %>%
  summarize(
    std_dev_german_pop = sd(german_pop, na.rm = TRUE)
  ) %>%
  arrange(std_dev_german_pop)

berlin_plans_15 <- berlin_plans_15 %>%
  inner_join(std_dev_filtered_draws, by = "draw")

```
The last chunk create Figure 8, which are the top 6 plans in which no constituency deviates more than 15 per cent from the mean population size, ordered based on the standard deviation of the German population.
```{r}
png(filename = "final_figures/figure 7/simulations_deviations_15.png", width = 12, height = 8, units = "in", res = 300)

redist.plot.plans(std_dev_filtered_draws, draws = 1:6, shp = berlin_redist)

dev.off()
```


